---
path: '/part-19/7-quiz'
title: 'Quiz and Cheatsheet'
hidden: false
---

<p>Why can’t we <code>map Nothing</code>?</p>
<ol className="quiz-list">
<click-quiz correct>
Because <code>Nothing</code> doesn’t take arguments
</click-quiz>
<click-quiz>
Because <code>Nothing</code> returns nothing
</click-quiz>
<click-quiz>
Because <code>Nothing</code> is a constructor.
</click-quiz>
</ol>
<p>If we define <code>data Boing = Frick String Boing (Int -&gt; Bool)</code>, what is the type of <code>Frick</code>?</p>
<ol className="quiz-list">
<click-quiz>
<code>Boing</code>
</click-quiz>
<click-quiz>
<code>String -&gt; Boing -&gt; Int -&gt; Bool -&gt; Boing</code>
</click-quiz>
<click-quiz correct>
<code>String -&gt; Boing -&gt; (Int -&gt; Bool) -&gt; Boing</code>
</click-quiz>
</ol>
<p>If we define <code>data ThreeLists a b c = ThreeLists [a] [b] [c]</code>, what is the type of the constructor <code>ThreeLists</code>?</p>
<ol className="quiz-list">
<click-quiz>
<code>[a] -&gt; [b] -&gt; [c] -&gt; ThreeLists</code>
</click-quiz>
<click-quiz>
<code>a -&gt; b -&gt; c -&gt; ThreeLists a b c</code>
</click-quiz>
<click-quiz correct>
<code>[a] -&gt; [b] -&gt; [c] -&gt; ThreeLists a b c</code>
</click-quiz>
<click-quiz>
<code>[a] -&gt; [b] -&gt; [c] -&gt; ThreeLists [a] [b] [c]</code>
</click-quiz>
</ol>
<p>If we define <code>data TwoLists a b = TwoList {aList :: [a], bList :: [b]}</code>, what is the type of the function <code>aList</code>?</p>
<ol className="quiz-list">
<click-quiz>
<code>aList</code> is not a function, it is a field
</click-quiz>
<click-quiz correct>
<code>TwoLists a b -&gt; [a]</code>
</click-quiz>
<click-quiz>
<code>[a] -&gt; TwoLists a b</code>
</click-quiz>
<click-quiz>
<code>[a]</code>
</click-quiz>
</ol>


## Cheatsheet

Thanks again to our TA Daan Wichmann for the following cheatsheet.
Note that while this cheatsheet can help you to prepare for the exam, it is non-exhaustive, and your own responsibility that you go through all material.

```haskell
import qualified Data.Map as Map  -- Qualified import Data.Map as Map (because of overlap with Prelude)
import Data.Array

myTuple :: (String,String)
myTuple = ("Hello","World!")

-- fst :: (a, b) -> a
-- snd :: (a, b) -> b

-- zip :: [a] -> [b] -> [(a, b)]
-- unzip :: [(a, b)] -> ([a], [b])

-- elements that satisfy and don't satisfy a predicate
-- partition :: (a -> Bool) -> [a] -> ([a], [a])

-- swap :: (a,b) -> (b,a)

-- sum all numbers that are paired with True
sumIf :: [(Bool,Int)] -> Int
sumIf [] = 0
sumIf ((True,x):xs) = x + sumIf xs
sumIf ((False,_):xs) = sumIf xs

summed = sumIf [(True,1),(False,10),(True,100)]
-- Output: 101

-- FOLDING
-- foldr :: (a -> b -> b) -> b -> [a] -> b
-- foldr f y []     = y
-- foldr f y (x:xs) = f x (foldr f y xs)

-- nub :: Eq a => [a] -> [a] (removes duplicates from lists)

-- Ord type class is used for ordering operations (>=, <=, >, <, min, max)

-- Num type class contains integer arithmatic (also shows up in in types of integer literals)
-- (+) :: Num a => a -> a -> a
-- (-) :: Num a => a -> a -> a
-- (*) :: Num a => a -> a -> a
-- negate :: Num a => a -> a                  0-x
-- abs :: Num a => a -> a                     absolute value
-- signum :: Num a => a -> a                  -1 for negative values, 0 for 0, +1 for positive values
-- fromInteger :: Num a => Integer -> a

-- Integral is the type class that represents all whole numberts (Int, Integer)
-- All types that belong to Integral also belong to Num
-- div :: Integral a => a -> a -> a
-- mod :: Integral a => a -> a -> a

-- Fractional is the class for types that have division (all types of Fractional also belong to Num)
-- (/) :: Fractional a => a -> a -> a

-- Floating contains some additional operators that only make sense for floating point numbers.
-- All types that belong to Floating also belong to Factional (and so, also to Num)
-- sqrt :: Floating a => a -> a
-- sin :: Floating a => a -> a

-- Read and Show
-- show :: Show a => a -> String
-- read :: Read a => String -> a

readInt = read "127" :: Int -- We tell the compiler to read to an Int (could also be a float for example)

-- Foldable: represents types you can fold over

-- MAPS

-- Create a Map from a list of key-value pairs
-- Map.fromList :: Ord k => [(k, a)] -> Map.Map k a

-- Insert a value into a map. Overrides any previous value with the same key.
-- Returns a new map. Does not mutate the given map.
-- Map.insert :: Ord k => k -> a -> Map.Map k a -> Map.Map k a

-- Get a value from a map using a key. Returns Nothing if the key was not present in the map.
-- Map.lookup :: Ord k => k -> Map.Map k a -> Maybe a

-- An empty map
-- Map.empty :: Map.Map k a

-- Maps are implemented as ordered binary search trees (thats why we need the Ord type constraint)

withdraw :: String -> Int -> Map.Map String Int -> Map.Map String Int
withdraw account amount bank =
    case Map.lookup account bank of
        Nothing  -> bank                                   -- account not found, no change
        Just sum -> Map.insert account (sum-amount) bank   -- set new balance

-- Equivalent
withdrawAdjust :: String -> Int -> Map.Map String Int -> Map.Map String Int
withdrawAdjust account amount bank = Map.adjust (\x -> x-amount) account bank

-- ARRAY

-- Type signature of array
-- array :: Ix i => (i, i) -> [(i, e)] -> Array i e

myArray :: Array Int String
myArray = array (7,11) [(7,"seven"), (8,"eight"), (9,"nine"), (10,"ten"), (11,"ELEVEN")]

-- listArray :: Ix i => (i, i) -> [e] -> Array i e

-- Equivalent to myArray
myListArray :: Array Int String
myListArray = listArray (7,11) ["seven", "eight", "nine", "ten", "ELEVEN"]

-- Array lookup
-- (!) :: Ix i => Array i e -> i -> e
-- Array update
-- (//) :: Ix i => Array i e -> [(i, e)] -> Array i e

-- arrays and maps are also Foldable (so you can use length and foldr)
```

